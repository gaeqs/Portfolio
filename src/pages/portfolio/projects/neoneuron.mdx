---
layout: /src/layouts/ProjectLayout.astro
title: 'Neoneuron'
pubDate: 2026-05-15
description: 'Ph.D. Thesis. A novel methodology for real-time generation of neuronal morphology using Mesh Shaders and compact procedural representations.'
languages: [ cpp, vulkan, glsl, mesh-shaders, research ]
image:
  url: "/images/projects/Neoneuron/neoneuron.png"
  alt: "Neoneuron"
github: "https://github.com/gaeqs/Neoneuron"
---

import FeatureCard from '/src/components/ui/FeatureCard.astro'
import Challenge from '/src/components/ui/Challenge.astro'
import Gallery from '/src/components/ui/Gallery.astro'
import Figure from '/src/components/ui/Figure.astro'


**Neoneuron** represents the culmination of my Ph.D. research: a paradigm shift in how biological structures are rendered.

Traditional visualization methods rely on pre-computed meshes, which consume massive amounts of VRAM and lack flexibility. This project introduces a **GPU-Driven Procedural Pipeline** utilizing the modern **Mesh Shader** architecture to generate geometry on-the-fly from compact skeletal descriptions.

<Figure
    src="/images/projects/Neoneuron/neuron.gif"
    alt="Neoneuron Real-time Simulation"
    caption="Real-time procedural generation of millions of neuronal segments directly on the GPU."
    fullWidth={true}
/>

## The Core Innovation: "The Schemlet"

The central contribution of this research is the **Schemlet**[cite: 354]. Unlike a meshlet (which stores geometry), a Schemlet is a **blueprint**. It is a lightweight, symbolic instruction packet that tells the GPU *how* to build a part of the neuron.

<div class="grid grid-cols-1 md:grid-cols-3 gap-4 my-8">
    <FeatureCard title="1. Symbolic Data" color="blue">
        Instead of storing vertices, we store **morphological data**: start/end points, radii, and parent indices. This reduces memory footprint by **up to 38x** compared to explicit meshes[cite: 505].
    </FeatureCard>

    <FeatureCard title="2. Task Shader Filtering" color="purple">
        Before generation, **Task Shaders** analyze Schemlets in parallel. They perform aggressive frustration culling and calculate continuous **Level of Detail (LOD)** factors per segment[cite: 432].
    </FeatureCard>

    <FeatureCard title="3. Mesh Shader Synthesis" color="orange">
        Visible Schemlets are expanded into geometry by **Mesh Shaders**. The GPU procedurally generates tubes (neurites) and deformed spheres (somas) just in time for rasterization[cite: 458].
    </FeatureCard>
</div>

## Scientific Methodology

The pipeline replaces the traditional Input Assembler with a compute-like structure tailored for biology.

### 1. Ingestion & Decomposition
The CPU is only responsible for decomposing the neuronal skeleton (SWC format) into a flat array of Schemlets: **Segment**, **Bifurcation**, and **Soma**[cite: 421]. This ensures the "Decoupled Procedural Logic" principle[cite: 324].

### 2. The Bifurcation Problem
One of the hardest challenges in procedural mesh generation is creating watertight joints at branching points.
Neoneuron solves this by pre-calculating optimal division angles and letting the Mesh Shader generate a seamless "patch" that stitches the parent and child segments, guaranteeing **crack-free geometry** even at varying LODs[cite: 428, 450].

<Gallery images={[
    { src: "/images/projects/Neoneuron/bifurcation_wireframe.jpg", alt: "Procedural Bifurcation Topology (Fig. 5)" },
    { src: "/images/projects/Neoneuron/soma_lod.jpg", alt: "Adaptive Soma Tessellation (Fig. 4)" },
    { src: "/images/projects/Neoneuron/lod_segments.jpg", alt: "Continuous Level of Detail (Fig. 3)" },
]} />

## Research Results

The methodology was validated against industry-standard tools like **NeuroTessMesh** and **Neuronize**. The results demonstrate that proceduralism is superior for large-scale visualization.

### Memory Efficiency (VRAM)
By discarding explicit geometry, Neoneuron drastically reduces memory pressure. In scenes where *Neuronize* consumed 15 MiB per neuron, Neoneuron used less than **0.5 MiB**[cite: 505].

<Figure
    src="/images/projects/Neoneuron/vram_chart.png"
    alt="VRAM Usage Comparison Chart (Fig. 8)"
    caption="Comparative analysis of VRAM usage. Neoneuron (left) vs Traditional approaches."
/>

### Performance (FPS)
Despite the heavy ALU load of generating meshes every frame, the elimination of memory bandwidth bottlenecks results in a **2x performance increase** over tessellation-based approaches like NeuroTessMesh[cite: 518].

## Challenges & Contributions

<Challenge title="The Memory Wall">
    <p slot="challenge">
        Scientific datasets contain millions of neurons. Storing them as static OBJ/FBX models exceeds the VRAM of even high-end workstations (e.g., 38x more memory usage [cite: 505]).
    </p>
    <div slot="solution">
        I shifted the paradigm from **Storage** to **Compute**. By streaming compact *Schemlets* and generating vertices only when needed, the scene size is decoupled from geometric complexity.
    </div>
</Challenge>

<Challenge title="Topology Continuity">
    <p slot="challenge">
        Procedural meshes often suffer from "cracks" or holes when different parts (like a dendrite and a soma) meet, especially when they have different LOD levels.
    </p>
    <div slot="solution">
        The **Bifurcation Schemlet** logic acts as a topological bridge. It matches the vertex density of the parent and children dynamically, creating a mathematically perfect seal[cite: 468].
    </div>
</Challenge>

## Citation

If you find this methodology useful for your research, please cite the paper:

```bibtex
@article{rial2024methodology,
  title={Methodology for Real-Time Generation and Visualization of Three-Dimensional Models Using Mesh Shaders},
  author={Rial Costas, Gael and Mata, Susana and Robles Sánchez, Óscar David},
  journal={IEEE Transactions on Visualization and Computer Graphics},
  year={2024}
}